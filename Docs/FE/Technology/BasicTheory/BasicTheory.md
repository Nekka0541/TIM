# 基礎理論
- [基礎理論](#基礎理論)
  - [基数変換](#基数変換)
  - [補数](#補数)
    - [補数](#補数-1)
      - [2の補数の作り方](#2の補数の作り方)
    - [固定小数点](#固定小数点)
  - [浮動小数点](#浮動小数点)
      - [浮動小数点の形式](#浮動小数点の形式)
  - [誤差](#誤差)
    - [誤差](#誤差-1)
      - [桁あふれ誤差](#桁あふれ誤差)
      - [丸め誤差](#丸め誤差)
      - [桁落ち誤差](#桁落ち誤差)
      - [情報落ち誤差](#情報落ち誤差)
      - [打ち切り誤差](#打ち切り誤差)
  - [シフト演算](#シフト演算)
    - [シフト演算](#シフト演算-1)
    - [論理シフト](#論理シフト)
    - [算術シフト](#算術シフト)
      - [算術左シフト](#算術左シフト)
      - [算術右シフト](#算術右シフト)
    - [シフト演算まとめ表](#シフト演算まとめ表)
    - [シフト演算と加算の組み合わせ](#シフト演算と加算の組み合わせ)
  - [論理演算](#論理演算)
    - [論理演算](#論理演算-1)
    - [ビット演算](#ビット演算)
  - [半加算器と全加算器](#半加算器と全加算器)
    - [加算器](#加算器)

## [基数変換](./RadixConversion.md)

## 補数

### 補数
2進数でしか判断できないコンピュータ内部で、負数を表現する方法の一つとして、補数表現がある。

- 補数は、ある数を決められた数にするために、「補う数」です。
- N進数には、「Ｎ－1の補数」と「Ｎの補数」がある。
- N-1の補数
  - ある数にＮ－１の補数を補うと、与えられた桁数の最大値となる。
- Nの補数
  - ある数にNの補数を補うと、与えられた桁数の次の桁に桁上がりする。

10進数には９の補数と10の補数の二つがある。
- 例えば10進数3桁で表現する場合 [123]
  - 9の補数は876
    - 123+876=999
  - 10の補数は877
    - 123+877=1000
    - ここで、10進数３桁での表現であるため、桁上がりした千の位の1は無視される。なので、123+877=000となる。
    - つまり、0になるので10の補数877は123の対の負数（-123）の意味にもなってくる。
      > このように補数を使って負数を表現することができる。

- 2進数
2進数にも同じような補数がある。
2進数4ビットで表現「0101」の補数を見てみよう
  - 1の補数は「1010」
  - 2の補数は「1011」
    - 10の補数に同じく、0101の負数としての意味も持っている
- コンピュータ内部では演算回路を簡単にするため、2の補数を利用して負数を表現している。
- 補数を使うことで、減算を加算で処理できる。

#### 2の補数の作り方
- 2の補数は1の補数に+1した値。
- 1の補数は正数（比較対象の正の2進数）のビット反転をした値
- 2の補数（負数）から対の正数を求めるには逆にビット反転して＋１すれば求められる

### 固定小数点
コンピュータ内部における数値の表現方法として、固定小数点と浮動小数点がある。
- 固定小数点は小数点の位置を決められた場所に固定して表現する形式
- 整数型として扱う場合は、最右端の右側に小数点がある。
- 負数を扱う場合は、最左端ビットを符号ビットとした２の補数表現を用いる。
  - 例　2進数8ビットの固定小数点（負数は２の補数）
    - 最小値:10000000  (10進で-128)
    - 最大値:01111111（10進数で127）

## 浮動小数点
浮動小数点は実数（小数点のついた数）を扱う場合に使用する形式。  指数を使うことで大きな数や小さな数を固定小数点よりも少ないビット数で表現できます。

#### 浮動小数点の形式
浮動小数点の形式にはいくつもの種類がある。代表的なのはIEEE754,32ビット（単精度）形式

数値は$(-1^S)\times B\times{2^E}$と表現する

- 符号部　S 1bit
  - 仮数部の符号（０：正、１：負）
- 指数部　E 8bit
  - ２を基数として、実際の値に127を加えたバイアス値
- 仮数部  B 23bit
  - 絶対値を２進数で表す。1.Mとなるように桁移動する。（正規化）

- 試しにやってみよう
- １０進数7.25をIEEE754で表現してみよう
1. 正数なので符号Sに0を入れる
2. 7.25を２進数で表現すると111.01 仮数部が1.Mになるように正規化する。
   - $111.01\times{2^0} -正規化> 1.1101\times{2^2}$
   - 仮数部の最上位から順に1101残りのビットに0を入れる。仮数部の1.は自明なので省略されている。
3. 指数部は2+127=129,2進数に基数変換して10000001を入れる

- こっちのほうが分かりやすい(https://medium-company.com/%E6%B5%AE%E5%8B%95%E5%B0%8F%E6%95%B0%E7%82%B9%E6%95%B0-%E5%9F%BA%E6%9C%AC%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85%E8%A9%A6%E9%A8%93/#i)

## 誤差

### 誤差
電卓なら、８桁、１２桁のように表現できる桁の上限が決まっています。コンピュータ内部でも、数値を指定されたビット数で表現しているために、真の値と表現する値に差が発生します。
これを誤差といって、以下のような種類がある。

#### 桁あふれ誤差
桁あふれ誤差は演算結果がコンピュータの表現できる範囲を超えることで発生する誤差
- オーバーフロー
  - 演算結果が表現できる範囲を超えてしまうこと
- アンダーフロー
  - 浮動小数点では限りなく0に近づいて表現しきれなくなり発生する。

#### 丸め誤差
丸め誤差は指定された桁数で演算結果を表すために切り捨て、切り上げ、四捨五入などを行うことで発生する誤差

#### 桁落ち誤差
桁落ち誤差は絶対値がほぼ等しい数値の間で、同符号の減産や異符号の加算をしたときに有効桁数が減ることで発生する誤差

例 $0.556\times10^7 - 0.552\times10^7$

$= 0.004\times10^7 正規化-> 0.400\times10^7$
> 正規化すると末尾に00が付きますが、これは正確性とは関係のない数字で、有効桁ではない。有効桁は１桁に減ってしまうことになる。このように桁落ち誤差は、有効桁数が減ってしまう現象。

#### 情報落ち誤差
絶対値の差が非常に大きい数値の間で加減算を行ったときに絶対値の小さい数値が計算結果に反映されないことで発生する誤差

例：$0.123\times10^2 + 0.124\times10^{-2}$
> 有効桁数は仮数部３桁
> 浮動小数点どうしを加減算するときは指数をそろえる必要がある。指数は大きいほうにそろえる

↑を踏まえると、、、
$0.123\times10^2+0.0000124\times10^2=0.1230124\times10^2 正規化→0.123\times10^2$
> $0.123\times10^2$となっている。！？小さな数$0.124\times10^{-2}$はどこ行った？？

のように情報落ち誤差は発生する。絶対値の小さな数値の有効桁数の一部または全部が結果に反映されない現象です。
> なお、数多くの数値の加減算を行うときは、絶対値の昇順に数値を並び替えてから計算すると、情報落ちの誤差を小さくすることができる。

#### 打ち切り誤差
浮動小数点数の計算処理の打ち切りを指定した規則で行うことによって発生する誤差

例えば円周率は3.14159と続くが、計算処理を打ち切って3.14とすることによって発生する。

## シフト演算

### シフト演算
左右にビットをずらして（シフトして）乗算や除算の演算をすることを**シフト演算**という。なおシフト演算には符号を考慮しない**論理シフト**と符号を考慮する**算術シフト**がある。

### 論理シフト
符号を考慮しないシフト演算です。論理シフトでは左シフト・右シフト、ともにあふれたビットは捨てられ、空いたビットには０が入る。

### 算術シフト
符号を考慮するシフト演算です。左シフトと右シフトでは空いたビットの取り扱い方が異なる。

#### 算術左シフト
算術左シフトでは符号ビットはそのままの位置にして、あふれたビットは捨てられ、空きビットには０が入る。

#### 算術右シフト
算術右シフトでは符号ビットはそのままの位置に、あふれたビットは捨てられ、空きビットには符号ビットと同じビットが入る。

### シフト演算まとめ表
| シフト種類   | 符号ビット   | あふれたビット | 空いたビット           |
| :----------- | :----------- | -------------- | ---------------------- |
| 論理シフト   | -            | 捨てる         | 0が入る                |
| 算術左シフト | 位置そのまま | 捨てる         | ０が入る。             |
| 算術右シフト | 位置そのまま | 捨てる         | 符号ビットと同じビット |

### シフト演算と加算の組み合わせ
シフト演算を使うと$2^n$倍や$\frac{1}{2}^n$倍は簡単にできることがわかりました。それでは例えば２進数ｍの９倍の値を求めるにはどうすればよい？

この際は9を2のべき乗に分解する。

$$
\begin{align}
&m\times9\\
&=m\times(2^3)+1\\
&=m\times2^3+m
\end{align}
$$
このように変形して、mを3ビット左にシフト移動したものにｍを加えると、9倍の数値を求めることができる。
> 基数変換だけじゃなくてn進数（10進数以外）同士の計算もやっときたい

## 論理演算
### 論理演算
論理演算は１と０または真と偽のように2つの値のうちいずれかの一方の値を持つデータ間で行われる演算です。演算結果も1と0または真と偽です。
論理演算を実際に行う電子回路が論理回路でCPUに組み込まれている。

論理回路は**MIL記号**で図式化したり入力の状態とその時の出力の状態を表にまとめた**真理値表**で表現したりします。ベン図で考えると理解しやすいです。

- [論理演算の図一覧](https://images.app.goo.gl/1gWVtkBGiw1V4EYbA)

それぞれの論理演算の簡単な説明を以下の表に表す
| 論理演算                   | 説明                                                                                                                                    |
| :------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------- |
| 論理和（OR）               | 入力ABのうち、どちらか一方でも１であれば出力は１となる演算　「＋」は論理和を表す。                                                      |
| 論理積(AND)                | 入力ABの両方が１であれば出力が１となる演算　「・」は論理積を表す。                                                                      |
| 否定(NOT)                  | 入力は一つである。入力が０であれば出力は１、入力が１であれば出力は０になる演算。　「Ā」はAの否定を表す。                                |
| 排他的論理和(EORまたはXOR) | 入力ABが異なる入力値の場合、出力は１となる演算　「⊕」は排他的論理和を表す　また、排他的論理和は$A\cdot\overline{B}+\overline{A}\cdot B$ で表す。|
| 否定論理和(NOR)            | 論理和と否定を組み合わせた演算。入力ABどちらもない状態（０）にのみ出力があります。 $\overline{A+B}$は否定論理和を表す。　$A+B(論理和)$の否定形です。                |
| 否定論理積(NAND)           | 論理積と否定を組み合わせた演算。　「$\overline{A\cdot B}$」は否定論理積を表す |

### ビット演算
元のビット列と特定のビット列との間でビット演算を行い、ある特定のビットを取り出したり、反転させたりすることができる。この時の「特定のビット列」はマスクパターンと呼ばれている。

例えば、２進数ビットの下位４ビットを操作してみる。
- 下位４ビットを操作するには下位４ビットに１、それ以外のビットに０を入れたビット列をマスクパターンとして使う。
> 00110001 -> 00001111

- [ビット列取り出し、反転について](https://www.sumappu.com/post-1138/#)

## 半加算器と全加算器
### 加算器
加算器は2進数の加算を行う回路